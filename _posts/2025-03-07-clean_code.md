---
title: Clean Code(클린 코드) | 로버트 C. 마틴 | 인사이트 | 2013.12.24. 
description: 애자일 소프트웨어 장인 정신
author: yuna
date: 2025-03-07 20:58:00 +0900
categories: [BookReview]
tags: [CleanCode]
pin: false
math: true
mermaid: true
---

#### 의미있는 이름
의도를 밝힌 이름 사용
  예) theList => gameBoard
검색하기 쉬운 (중복이 적은) 이름 사용
클래스는 명사, 메서드는 동사로 이름 지정

#### 함수
함수는 짧게 작성
함수는 한가지를 해야하고 그 한가지 만 을 잘해야 한다
함수는 SRP(Single Responsebility Principle), OCP(Open Closed Principle) 원칙을 지킨다
함수명을 서술적인 이름으로 지정한다
함수 인수는 3개가 넘지 않도록 한다
함수에 플래그(T/F) 인수는 넣지 않도록 한다
명령과 조회는 각각 분리한다
오류 코드로 분기처리 하지 않고 예외(try~catch)를 사용하라
반복하지않고 include 방법으로 중복을 최소화하라
AOP, COP는 중복 제처 전략이 포함되어 있다
함수가 큰 경우 return 문이 하나만 존재해야 한다
루프문 안에 break, cintinue, goto를 사용하지 않는다

* DSL = Domain Specific Language 도메인 특화 언어

#### 주석
주석이 필요없는 코드를 짜라, 이름을 지정할때도 목적을 표현한 이름을 사용함으로써 주석 최소화하라
좋은 주석은 주석을 달지 않을 방법을 찾아낸 주석이다

#### 형식 맞추기
빈 행으로 메소드 등의 각 기능을 구분한다
서로 밀접한 개념은 세로로 가까이 둔다
변수는 사용할 위치에 최대한 가까이 선언한다
인스턴스 변수는 클래스 맨 처음 선언하고 변수간 거리를 두지 않는다
종속 함수의 경우 호출하는 함수를 호출되는 함수보다 먼저 배치한다
상수는 실제 사용되는 함수에 파라미터로 넘겨주는 방식으로 구현하라
가로 글자수는 120 정도가 적당하다
할당 연산자를 강조하기 위해 앞,뒤 공백을 주는게 좋다
우선순위를 강조하기 위한 앞,뒤 공백은 좋다

#### 객체와 자료구조
추상인터페이스를 제공해 사용자가 구현을 모른채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스이다
디미터법칙은 휴리스틱으로 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다
DTO(Data Transfer Object)는 공개변수만 있고 함수가 없는 전형적인 자료 구조체 형태이다
빈(Bean)은 비공개 변수를 조회, 설정 함수로 조작하는 형태이다
활성레코드는 공개변수가 있거나 비공개 변수에 조회, 설정 함수가 있으며 save, find와 같은 탐색함수도 제공한다
활성레코드에 비즈니스 규칙 메서드를 추가하여 객체로 취급하는 잡종코드가 되지 않도록 한다
절차적인 코드는 기본 자료구조를 변경하지 않으면서 새 함수를 추가하기 쉽고, 객체지향 코드는 기존함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다
객체는 동작을 공개하고 자료를 숨긴다, 함수 변경이 어렵고 객체 추가가 용이하다
자료구조는 별다른 동작 없이 자료를 노출한다, 함수 변경이 쉽고 객체 추가가 어렵다

#### 오류 처리
오류코드보다 예외 try~catch 사용
RuntimeException 상속한 예외로 NullPoiterException, ArrayIndexOutOfBoundsException, ArithmeticException 등 미확인 unchecked 예외를 사용하고,
checked Exception 확인된 예외에는 IOException, SQLException이 있다 코드가 실행되기 전 컴파일러가 예외처리 확인
오류메세지에 정보(실패한 연산이름, 실패유형 등)를 담아 예외와 함께 던진다
예외 클래스를 정의해서 예외를 감싸기기법을 사용한다
특수사례 패턴으로 클래스를 만들거나 객체를 조작해 특수사례처리, 클래스나 객체가 예외적인 상황을 캡슐화해서 처리
null을 전달하지 않도록 한다

#### 경계
경계 인터페이스를 이용할 때 이를 이용하는 클래스나 클래스 계열 밖으로 노출하지 않는다
외부코드 삽입 시 외부코드의 객체를 그대로 사용하지 않고 감싸서 캡슐화하거나 공개 API 인수로 넘기거나 반환값으로 사용하지 않는다
학습 테스트는 프로그램에서 사용하려는 방식대로 외부 API 호출
통제된 환경에서 API를 제대로 이해하는지 확인
아직 존재하지 않은 코드 사용할 때는 바라는 인터페이스를 구현 후에 컨트롤러 구현, API 정의되면 adapter를 구현해 간격 메움
Adapter 패턴으로 API 사용을 캡슐화해 API가 바뀔 때 수정할 코드를 한곳으로 모음
외부 패키지를 호출하는 코드를 가능한 줄이고 새로운 클래스로 감싸거나 Adapter 패턴을 사용한다

#### 단위 테스트
TDD 세가지 방법
1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다
2. 컴파일은 실패하지않으면서 실행이 실패하는 정도의 단위 테스트를 작성한다
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다

테스트 코드도 깨끗하게 유지한다
테스트는 유연성, 유지 보수성, 재사용을 제공한다
실제 환경에서는 절대 안되지만 테스트 환경에서는 문제 없는 방식은 이중 표준(메모리와 CPU 효율의 문제로 실제 환경에서는 절대로 안 되지만 테스트 환경에서는 절대 문제없는 방식)을 사용해도 괜찮다
테스트 당 assert 하나, 중복이 많은 경우 template method 패턴 사용 (단, 테스트를 위한 소스 구현에 공수가 많이 들 수 있음)
테스트 함수마다 한 개념만 테스트
꺠끗한 테스트는 F.I.R.S.T 규칙을 따른다
- F: fast. 테스트는 빨리 돌아야 한다
- I: independent. 각 테스트는 독립적이고 서로 의존하지 않는다
- R: repeatable. 어떤 환경에서도 반복 가능해야 한다
- S: self-validating. 테스트는 bool값으로 결과를 내야한다
- T: timely 테스트는 실제 코드를 구현하기 직전에 구현한다

#### 클래스
정의 순서
1. 정적 공개 상수
2. 정적 비공개 변수
3. 비공개 인스턴스 변수
4. 공개 함수
5. 비공개 함수는 자신을 호출하는 공개함수 직후

캡슐화 클래스는 작아야 한다, 작음의 기준은 25단어 내외로 클래스 설명이 가능해햐 하고 간결한 이름이어야 한다
단일 책임 원칙으로 클래스나 모듈은 변경할 이유가 단 하나뿐이어야 한다는 사실을 기반으로 클래스의 크기를 지정한다
모든 인스턴스 변수를 메서드마다 사용하는 클래스 응집도가 높은 클래스는 바람직하지 않다
클래스가 응집력을 잃는다면 쪼갠다
변경하기 쉬운 클래스여야 한다
추상 클래스를 사용해 결합도를 낮춘다 DIP(Dependency Inversion Principle)

#### 시스템
시스템 제작과 사용을 분리하라 -> 갹채 제작, 의존성 연결 준비과정과 런타임로직 분리
설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다. 즉 관심사 분리의 원칙을 따른다
최선의 시스템 구축은 POJO 객체로 구현되는 모듈화된 관심사 영역(도메인)으로 구성한다
낮은 결합도와 높은 응집도를 목표로 설계해야 한다
도메인 특화언어(DSL)를 사용해 모든 추상화 수준과 모든 도메인을 POJO로 표현 할 수 있다
모든 추상화 단계에서 의도는 명확히 표현한다
모든 객체가 전반적으로 동일한 방식을 이용하게 만들어야 한다

#### 창발성
단순한 설계규칙
1순위: 모든 테스트를 실행하라
2순위: 중복을 없앤다
3순위: 프로그래머 의도를 표현한다
4순위: 클래스와 메서드 수를 최소로 줄인다

#### 동시성
동시성은 무엇(What)과 언제(When)을 분리하여 결합을 없애는 전략이다
동시성 코드는 다른 코드와 분리하여 작성한다
공유 객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 보호하라
자료를 캡슐화하고 공유자료를 최대한 줄여라
공유자료 대신 객체를 복사해 읽기 전용으로 사용하라
스레드는 가능한 독립적으로 구현하라
각 스레드는 클라이언트 요청 하나 처리
독자적인 스레드로 가능하면 다른 프로세서에서 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라
스레드 환경에 안전한 컬렉션 사용
서로 무관한 작업 수행 시 executor 프레임워크 사용
가능하다면 스레드가 차단(blocking)되지 않는 방법 사용
일부 클래스 라이브러리는 스레드에 안전하지 못하다
공유 객체 하나에는 메서드 하나만 사용하라, 만약 여러 메소드를 사용하는 경우 클라이언트에서 첫번째 메서드를 호출하기 전에 잠그고 마지막 메서드까지 잠금 유지, 마지막 메서드 호출 후 잠금 해제한다
동기화 하는 부분은 최대한 작게 만들어라
이미 나온 알고리즘을 토대로 종료 코드를 올바르게 구현하라
문제를 호출하는 테스트 케이스를 작성하고 프로그램 설정, 시스템 설정과 부하를 부꿔가며 테스트한다
말이 안되는 실패는 잠정적인 스레드 문제로 취급하라
다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현한다
다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하라
프로세서 수 보다 많은 스레드를 돌려보라
다른 플랫폼에서 돌려보라
코드에 보조 코드(wait, sleep, yield, priority)를 넣어 돌려보라 강제로 실패를 일으키게 해본다
AOF, CGLIB, ASM 등의 도구를 사용해 무작위 보조코드 넣어보기
Contest 도구를 사용해 코드를 흔들어 jiggling 해보기

#### 점짐적인 개선

#### JUnit 들여다보기

#### serialData 리팩터링

#### 냄새와 휴리스틱
[주석]
주석에는 작성자, 최종수정일 SPR(Software Problerm Report)번호 등과 같은 메타 정보만 넣는다
주석 처리된 코드는 즉각 지운다

[환경]
한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 한다
모든 단위의 단위테스트는 한 명령으로 돌려야 한다

[함수]
함수에서 인수는 작거나 아예 없으면 좋다
출력 인수는 사용하지 않도록 한다
플래그 인수는 사용하지 않도록 한다
아무도 호출하지 않는 함수는 삭제한다

[일반]
소스파일 하나에 한 언어만 사용한다
함수나 클래스는 다른 프로그래머가 당연하게 여길만한 동작과 기능을 제공해야 한다
모든 경계조건을 테스트하는 테스트 케이스를 작성하라
실패하는 케이스를 제껴두지 않는다
중복은 추상화로 정리한다
switch/case나 if/else로 똑같은 조건을 거듭 확인하는 중복은 다형성 polymorphism으로 대체한다
알고리즘은 유사하나 코드가 다른 중복은 template method 패턴이나 strategy 패턴으로 중복을 제거한다
저차원 상세 개념은 파생클래스에 넣고 고차원 일반 개변은 기초클래스에 넣는다
기초 클래스가 파생 클래스를 사용, 의존하면 안된다. 기초클래스는 파생 클래스를 몰라야 한다
클래스나 모듈 인터페이스에 노출할 함수, 함수가 아는 변수, 인스턴스 변수는 작을수록 좋다.
자료, 유틸리티 함수, 상수, 임시변수를 숨겨라
메서드나 인스턴스 변수가 넘쳐나는 클래스는 피하라
하위 클래스에서 필요하다는 이유로 protected 변수나 함수를 마구 생성하지 마라
인터페이스를 매우 작게 그리고 매우 깐깐하게 만들어라
정보를 제한해 결합도를 낮춰라
죽은 코드는 삭제하라
변수와 함수는 사용되는 위치에 가깝게 정의하라
비공개 함수는 호출되는 위치 아래에 정의한다
표기법은 신중하게 선택하고 선택한 표기법은 일관성 있게 따른다
사용하지 않는 모든 코드는 삭제하고 깔끔하게 정리하라
서로 무관한 개념을 인위적으로 결합하지 않는다
함수, 상수, 변수 등을 선언할 때는 올바른 위치에 둔다
클래스 메서드는 자기 클래스의 변수와 함수에만 관심을 가지도록 해야한다
여러가지 값을 대신하는 로직은 분리하여 새로운 함수를 만든다
코드를 짤 때는 의도를 분명히 밝힌다
코드는 독자가 자연스럽게 기대할 위치에 배치한다
static 함수로 정의할 때 재정의할 가능성은 없는지 확인 후 정의한다
프로그램 가독성을 높이는 방법으로 계산을 여러 단계로 나누고 중간 값으로 서술적인 변수 이름을 사용한다
이름과 기능이 일치하도록 함수를 작성한다
알고리즘을 이해하라
다른 클래스로부터 의존하는 모듈에서 getOOO()과 같은 메서드를 추가하여 물리적 의존성을 작성한다
if/else, switch/case 보다 다형성을 사용한다
업계 표준에 기반한 구현 표준을 따르되 표준을 설명하는 문서는 코드 자체로 충분해야 하며 별도 문서를 만들 필요는 없어야 한다
코드에서 숫자를 사용하지 않고 상수를 지정하여 사용한다
코드에서 뭔가를 결정할 때는 정확히 결정한다
List로 선언할 변수를 ArrayList로 선언하는 행동은 지나친 제약이다
모든 변수를 protected로 선언한 코드는 무절제하다
통화를 다뤄야 한다면 정수를 사용하고 반올림을 올바로 처리한다
병행 특성으로 동시에 갱신할 가능성이 있다면 적절한 잠금 매커니즘을 구현한다
설계 결정을 강제할 때는 규칙보다 관례를 사용한다. 명명 관례도 좋지만 구조 자체로 강제하면 더 좋다
조건을 캡슐화하라
부정 조건을 피하라
함수는 한가지만 해야한다
시간적인 결합 즉 함수 실행순서가 중요한 경우 각 함수의 결과를 다음 함수에 사용하는 방식으로 시간적 결합을 노출한다
다른 클래스의 유틸리티가 아닌 public 클래스는 자신이 아닌 클래스 범위 안에서 선언하면 안된다, 패키지 최상위 수준에 선언하는게 관례다
코드의 일관성을 유지하라
경계조건을 캡슐화하라
추상화 수준은 함수 이름이 의미하는 작업보다 한 단계만 낮아야 한다
설정 정보는 최상위 단계에 둬라, 저차원 함수에 상수값을 정의하면 안된다
한 모듈은 주변 모듈을 모를수록 좋고 자신이 직접 사용하는 모듈만 알아야 하므로 추이적 탐색은 피한다

[자바]
클래스 둘 이상 사용 시 와일드 카드를 이용해 패키지 전체 가져오기
상수는 상속하지 않는다 대신 import static 을 사용하라
상수보다 enum 을 활용하라

[이름]
서술적인 이름을 사용하라
작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택하라, 구현을 드러내는 이름을 피하라
표준 명명법을 사용하라
함수나 변수의 목적을 명확히 밝히는 이름을 선택한다
이름 범위가 길 수록 이름을 정확하고 길게 짓는다
접두어는 뺀다
이름에 부수 효과도 같이 포함되도록 짓는다

[테스트]
잠재적으로 깨질만한 부분을 모두 테스트한다
커버리지 도구를 사용한다
사소한 테스트도 실행해본다
경계조건을 테스트한다
버그 주변은 철저히 테스트한다
실패 패턴을 살핀다
테스트 커버리지 패텬을 살핀다
테스트는 빨라야 한다는


#### 동시성
스레드 풀 사용시 executor 프레임워크 사용 추천
syncronized 키워드는 언제나 락Lock을 건다
다중 스레드 환경에서 안전하지 않은 클래스 - SimpleDataFormat, 데이터베이스 연결, Java.util 컨테이너 클래스, 서블릿
일반적으로 서버 기반 잠금이 바람직하다
- 코드 중복이 줄어든다
- 성능이 좋아진다
- 오류 발생 가능성이 줄어든다
- 스레드 정책이 하나다
- 공유변수 범위가 줄어든다
스레드 코드 테스트를 도와주는 도구 - ConTest(IBM)

더그 리 - Concurrent Programing in Java: Degign Principles and patterns
